<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>shellcoding on dubell.io</title><link>https://dubell.io/tags/shellcoding/</link><description>Recent content in shellcoding on dubell.io</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 27 Jan 2020 13:33:37 +0000</lastBuildDate><atom:link href="https://dubell.io/tags/shellcoding/index.xml" rel="self" type="application/rss+xml"/><item><title>SLAE 7: Creating your own crypter using golang</title><link>https://dubell.io/www/2020/01/slae-7-creating-your-own-crypter-using-golang/</link><pubDate>Mon, 27 Jan 2020 13:33:37 +0000</pubDate><guid>https://dubell.io/www/2020/01/slae-7-creating-your-own-crypter-using-golang/</guid><description>In this article, we will build a simple crypter for encrypting and decrypting shellcode. I chose to implement the crypter in Go using environmental keys.
I will not spend time implementing a fancy shellcode execution method in this article, only encryption and decryption methods are in scope for now.
Encryption The encryption/decryption process is using AES GCM and a specific file in /etc/ concatenated with the current user logged in as the key.</description></item><item><title>SLAE 6: Creating polymorphic shellcode</title><link>https://dubell.io/www/2020/01/slae-6-creating-polymorphic-shellcode/</link><pubDate>Sun, 26 Jan 2020 13:33:37 +0000</pubDate><guid>https://dubell.io/www/2020/01/slae-6-creating-polymorphic-shellcode/</guid><description>The goal of this article is to create polymorphic verions of three different shellcodes from http://shell-storm.org. Polymorphic shellcode has the ability to mutate its code everytime it runs. The instructions changes while algorithm stays intact. The purpose is to evade signature based detections without manually change the shellcode.
We won&amp;rsquo;t be creating our own polymorphic engine in this article, instead we will manually modify these three shellcodes from shell-storm.org:
Linux/x86 - shutdown -h now Shellcode - 56 bytes Linux/x86 - 40 byte shellcode to flush ipchains for Linux x86 Linux/x86 - Download + chmod + exec - 108 bytes We are not allowed to increase the size more than 50%.</description></item><item><title>SLAE 5: Analyzing shellcode generated by msfvenom</title><link>https://dubell.io/www/2020/01/slae-5-analyzing-shellcode-generated-by-msfvenom/</link><pubDate>Sat, 25 Jan 2020 13:33:37 +0000</pubDate><guid>https://dubell.io/www/2020/01/slae-5-analyzing-shellcode-generated-by-msfvenom/</guid><description>In this article, I will analyse three shellcode samples generated by msfvenom, specifically:
linux/x86/read_file linux/x86/adduser linux/x86/shell/reverse_tcp msfvenom --list payloads -a x86 --platform linux
Let&amp;rsquo;s see if there is something new we can learn from these samples :)
Analyzing linux/x86/read_file First, we generate the executable like so:
msfvenom -p linux/x86/read_file -a x86 --platform linux PATH=/etc/passwd FD=2 -f elf -o read_file
I set the payload options PATH and FD to /etc/passwd and 2.</description></item><item><title>SLAE 4: Custom encoder for bypassing signature based detection</title><link>https://dubell.io/www/2020/01/slae-4-custom-encoder-for-bypassing-signature-based-detection/</link><pubDate>Fri, 24 Jan 2020 13:33:37 +0000</pubDate><guid>https://dubell.io/www/2020/01/slae-4-custom-encoder-for-bypassing-signature-based-detection/</guid><description>Malware detection techniques has improved a lot over the years. Today companies are investing in machine learning methods for detecting malware, which sounds pretty cool if you ask me. However, there is one method that has been used since the first anti-virus software, which is signature based detection.
When disassembling a program you can analyze the assembly instructions in order to understand the program from the lowest level. It&amp;rsquo;s also possible from the assembly code to identify a set of unique instructions that identifies a specific program.</description></item><item><title>SLAE 3: Egg hunting in Linux x86 Assembly</title><link>https://dubell.io/www/2020/01/slae-3-egg-hunting-in-linux-x86-assembly/</link><pubDate>Wed, 22 Jan 2020 13:33:37 +0000</pubDate><guid>https://dubell.io/www/2020/01/slae-3-egg-hunting-in-linux-x86-assembly/</guid><description>When writing exploits, you sometimes encounter a situation where your payload is too big, you can&amp;rsquo;t fit your payload inside the buffer. This is where &amp;ldquo;eggs&amp;rdquo; come in to play. The basic idea of egg hunting is to divide the payload in to two parts, part one is the hunter while part two is the hunted (the egg). The hunter is a set of instructions that searches the program&amp;rsquo;s virtual address space for a given pattern (the egg).</description></item><item><title>SLAE 2: Creating a reverse TCP shell in x86 Assembly</title><link>https://dubell.io/www/2020/01/slae-2-creating-a-reverse-tcp-shell-in-x86-assembly/</link><pubDate>Tue, 21 Jan 2020 13:33:37 +0000</pubDate><guid>https://dubell.io/www/2020/01/slae-2-creating-a-reverse-tcp-shell-in-x86-assembly/</guid><description>What is a reverse TCP shell?
A reverse TCP shell is a program that instead of listening for incoming connections, the program will connect to a remote system and provide a local shell. This is useful in situations where the victim system is behind NAT, meaning you can&amp;rsquo;t directly connect to it, instead the server will connect to you. For this reason, reverse TCP shells are usually prefered over bind shells.</description></item><item><title>SLAE 1: Creating a bind shell in x86 Assembly</title><link>https://dubell.io/www/2020/01/slae-1-creating-a-bind-shell-in-x86-assembly/</link><pubDate>Mon, 20 Jan 2020 13:33:37 +0000</pubDate><guid>https://dubell.io/www/2020/01/slae-1-creating-a-bind-shell-in-x86-assembly/</guid><description>What is a bind shell?
A Bind shell is simply a program that listens for incoming connections. When a connection is made, a local shell is redirected to the newly created connection, thereby giving access to the local machine. Bind shells are usually created for backdoor access, although they could also be used for legitimate purposes, e.g. system administration.
ok, nuff said, let&amp;rsquo;s boogie Our program will follow these steps:</description></item></channel></rss>