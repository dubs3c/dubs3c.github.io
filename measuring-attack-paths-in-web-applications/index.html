<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><meta content="utf-8" http-equiv=encoding><link rel=preload href=/fonts/FiraCode-VariableFont_wght.ttf as=font type=font/ttf crossorigin><link rel=stylesheet href=/css/bootstrap-grid.min.css type=text/css><link rel=stylesheet href=/css/main.css type=text/css><meta name=apple-mobile-web-app-title content="dubell.io | Measuring attack paths in web applications"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="black-translucent"><meta name=twitter:site content="@dubs3c"><meta name=twitter:creator content="@dubs3c"><meta property="og:title" content="dubell.io | Measuring attack paths in web applications"><meta name=twitter:title content="dubell.io | Measuring attack paths in web applications"><meta itemprop=name content="dubell.io | Measuring attack paths in web applications"><meta name=application-name content="dubell.io | Measuring attack paths in web applications"><meta property="og:site_name" content="dubell.io"><meta property="og:article:published_time" content="2022-10-29T14:51:17+0200"><meta property="article:published_time" content="2022-10-29T14:51:17+0200"><base href=https://dubell.io/measuring-attack-paths-in-web-applications/><link rel=canonical href=https://dubell.io/measuring-attack-paths-in-web-applications/ itemprop=url><meta name=url content="https://dubell.io/measuring-attack-paths-in-web-applications/"><meta name=twitter:url content="https://dubell.io/measuring-attack-paths-in-web-applications/"><meta property="og:url" content="https://dubell.io/measuring-attack-paths-in-web-applications/"><meta property="og:article:author" content="Dubs3c"><meta property="article:author" content="Dubs3c"><meta name=author content="Dubs3c"><meta name=description content="Ideas and thoughts on how to measure attack coverage during a penetration test"><meta itemprop=description content="Ideas and thoughts on how to measure attack coverage during a penetration test"><meta property="og:description" content="Ideas and thoughts on how to measure attack coverage during a penetration test"><meta name=twitter:description content="Ideas and thoughts on how to measure attack coverage during a penetration test"><meta itemprop=image content="/"><meta property="og:image" content="https://dubell.io"><meta name=twitter:image content="https://dubell.io"><meta name=twitter:image:src content="https://dubell.io"><meta property="og:updated_time" content="2022-10-29T14:51:17+0200"><link rel=sitemap type=application/xml title=Sitemap href=https://dubell.io/sitemap.xml><title>dubell.io | Measuring attack paths in web applications</title></head><body><div id=particles-js></div><main><div class=row><div class=col><header style=text-align:center><a href=/ class=noleet><img href=/ class=banner-image src=/img/logo2.png alt=logo></a></header></div></div><div class=row><div class=col style=text-align:center><nav><fieldset><legend>n4vig4ti0n</legend><ul><li><a href=/>/etc/motd</a></li><li><a href=/www/>/var/www</a></li><li><a href=/mnt/>/mnt</a></li><li><a href=/usr/>/usr</a></li></ul></fieldset></nav></div></div><div class=content><article><h1>Measuring attack paths in web applications</h1><br><p class=small style=color:#999><a href=/categories/appsec>Appsec</a> / October 29, 2022 • 7 min read</p><p class=small><strong>Tags:</strong> <a href=/tags/code-review class=tag>Code Review</a></p><br><p>Recently a customer asked us after our penetration test against their web application, the percentage of possible attack paths we had covered. It was a difficult question to answer because, a) the customer wanted us to focus on SQL injection and XSS (long story why) and b) it was a legacy application from 2003 containing a lot of code. The short answer I gave was that since the test was focused towards SQLi and XSS, naturally, some attack paths were not considered. The customer understood this and accepted it.</p><p>During the following days after the test, I started to think more about measuring attack paths. I understand that, stating that a test has covered e.g. 45% of possible attack paths within a codebase, is valuable for a manager or C-level executive. However, I believe this statement contains too much nuance and can actually have a negative effect on any decisions derived from this statement. Which is the purpose of this article, to get into more detail and unravel the nuance.</p><p>Throughout this article, I will refer to the measurement of attack paths as, <em>attack coverage</em>.</p><h2 id=defining-an-attack-path>Defining an attack path</h2><p>In the context of the customer I previously described, the application being tested was a legacy ASP.NET application, most likely containing over 100k lines of code in total. Before diving into attack coverage, let&rsquo;s define an attack path. The way I see it, is that an attack path represents a context where a vulnerability of some sort can be exploited in order to perform some action, resulting in some consequence. The <em>vulnerability</em> and the <em>consequence</em> may have a high or a low severity, and a high or a low impact, depending on the context of the vulnerability. With this definition in mind, how do we determine our attack coverage? First we have to, once again, define where and how to look for vulnerabilities. This is where experience and expertise come into play, but for sake of simplicity, let&rsquo;s assume that vulnerabilities (can) occur where input from users are consumed. Keep in mind though, vulnerabilities may not necessarily be present in the first function call, they can reveal themselves several function calls later.</p><p>Consider the following request example:</p><p><img src=vuln-request-example.png alt=Example></p><p>We could say that the endpoint <code>/api/user</code> is an attack path, since it contains user input. However, it is technically not the endpoint itself that is the attack path, it is the HTTP verbs that it accepts. The image above shows a <code>PUT</code> request, used for modifying existing data. As shown in the image, there are a few vulnerability classes listed that can be investigated. But we can also examine <code>DELETE</code> requests which will delete users. <code>POST</code> requests are used for creating users, can we overwrite users? Can we create a user without verifying our email? Finally, <code>GET</code> requests can be used to retrieve users. How much data can we read from a user?</p><p>It is clear that for every endpoint, there exists sub-attack paths (HTTP verbs) with various exploitation possibilities resulting in unique consequences.</p><h2 id=why-enumerating-attack-paths-is-not-simple>Why enumerating attack paths is not simple</h2><p>Enumerating attack paths can be done statically, by counting the amount of supported HTTP verbs for each endpoint that accepts user input. This method assumes a whitebox approach, which may not always be the case. If so, enumeration can be performed in a blackbox, with zero insight into the codebase. In that case, attack paths can be enumerated dynamically, by crawling the application in order to determine all possible areas that accept user input. The downside of this approach is that some attack paths can be missed and therefore not included in the attack coverage.</p><p>However, simply stating that user input related endpoints are subject to application vulnerabilities, is wrong. The reason why is because vulnerabilities do not have to be <em>explicit</em>. For example, SQL injections are very clear and unequivocal (sometimes), other issues may not be, such as logic errors.</p><p>Without going into a detailed explanation of what logic errors are, let&rsquo;s assume for the sake of argument that a logic error is not an application vulnerability, rather an implementation based on a flawed or incomplete design.</p><p>An application can have one or multiple endpoints, perfectly secure, but may be entirely broken when seen from a design perspective. The code may be highly secure, but since its implementation is based on a faulty design, logic errors can be exploited.</p><p>Therefore, it is hard to reliably enumerate endpoints statically and say we have <code>X</code> attack paths. Because there exists a number of unknown attack paths that are not easily enumerated. For example, consider two low severity vulnerabilities that are insignificant by themselves, but if combined, can suddenly form a highly significant vulnerability. This type of an attack path is often hidden and not obvious, depending on how deep it&rsquo;s buried. Does not even have to be a combination of vulnerable endpoints that leads to a severe vulnerability. It can also be a set of requests executed in a specific order, resulting in a vulnerability.</p><h2 id=testing-methodology>Testing methodology</h2><p>In addition to the problems expressed in the previous section regarding enumeration, testing methodology is another issue. If 50 REST API endpoints have been discovered, and the pursuit of vulnerabilities is based on OWASP Top 10, most certainly some attack paths will be missed. However, let&rsquo;s say for the sake of simplicity, that these 50 endpoints only contain vulnerabilities described in OWASP Top 10, how can each vulnerability be discovered? Simply spraying <code>">&lt;script>alert(1)&lt;/script></code> everywhere may miss several contexts that would otherwise execute arbitrary JavaScript. Using a polyglot based XSS payload might increase the chances, but is not bullet proof. However, if it is a whitebox test, then enumerating all outputs where user input is presented is a very good way to determine if XSS vulnerabilities are present. Some template languages contain safe and unsafe functions used for displaying output. By simply evaluating whether unsafe methods are used within the codebase, it is possible to say with high confidence that XSS vulnerabilities do not exist. Of course, this depends on several factors, but is true in general.</p><p>Same process can be applied when looking for SQL injections. If all SQL queries are performed with prepared statements, it can be said with a high degree of certainty, that this codebase does not contain SQL injections (at this point in time). In a blackbox approach, nothing can be said with certainty, and requires more time and effort to uncover vulnerabilities, thereby requiring a higher degree of expertise from the tester.</p><p>This leads me to believe that in order to reliably determine the attack coverage, a whitebox approach is required. Although, a whitebox approach is not guaranteed to provide 100% attack coverage. But it will provide information that will produce a more accurate attack coverage.</p><h2 id=conclusion>Conclusion</h2><p>To summarize, it is hard to reliably enumerate endpoints statically and say we have x attack paths. In addition, any identified attack path is a snapshot in time and may change in the future, both in severity and what type of vulnerability needed in order to access it. New attack paths may also be introduced at any time.</p><p>Even though attack coverage is difficult to determine and contains a lot of nuance, it is still possible to say that we covered XX% of endpoints, where we found Y number of vulnerabilities. The issue with that statement, as I have described in this article, is that it does not convey how the endpoints were enumerated and what types of tests were performed. I would argue that, this is a general problem in the cyber security space, which leads us to this famous quote:</p><blockquote><p>Reports that say that something hasn&rsquo;t happened are always interesting to me, because as we know, there are known knowns; there are things we know we know. We also know there are known unknowns; that is to say we know there are some things we do not know. But there are also unknown unknowns—the ones we don&rsquo;t know we don&rsquo;t know. And if one looks throughout the history of our country and other free countries, it is the latter category that tends to be the difficult ones</p></blockquote><p>Perhaps strange quote to end with, but let me elaborate. Enumerating attack paths and identifying vulnerabilities can in some cases be automated and be statically verifiable. Other types of vulnerabilities require manual inspection. Both methods require a level of understanding of the particular context. It is hard to quantify the level of understanding required in order to identify vulnerabilities. But I would argue that at any level of expertise for a given area or context, there exists a knowledge gap where there are unknown unknowns, meaning vulnerabilities that we don&rsquo;t know, that we don&rsquo;t know.</p><p><strong>Future of AppSec</strong></p><p>We are seeing more and more improvements within the machine learning field. I hope that one day, ML tools can begin to understand context when &ldquo;reading&rdquo; code. Understanding what goes in and what goes out, and how that connects to the bigger picture. Hopefully, it can be combined with static analysis tools such as Semgrep to reliably identify vulnerabilities. The future of application security will not be dynamic or static analysis, it will be <strong>context driven analysis</strong>. You heard it here first, <em>*drops the mic*</em>.</p></article></div><footer></footer></main><script src=/js/particles.min.js defer></script><script src=/js/particles.conf.js defer></script><script src=/js/baffle.min.js async></script><script src=/js/main.js defer async></script></body></html>